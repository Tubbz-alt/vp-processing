# Extract vp data {#extract-vp}

```{r extract_rmd_settings, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

In this chapter we'll select, read, combine, filter and export data from vp files to a single, unaggregated CSV file.

```{r extract_load_libraries, results="hide"}
library(bioRad)
library(dplyr)
library(lubridate)
source("functions/vp_to_df.R")
source("functions/load_settings.R")
```

## Load settings

All of the filtering options we'll use here are defined in **yaml settings file**, which we pointed to in `setup.Rmd` (see \@ref(settings)). Let's load those:

```{r extract_load_settings}
settings <- load_settings(settings_file)
```

Found **`r length(settings$general$radar_ids_5char)` radars from `r length(settings$general$countries)` countries** in the settings.

## Select date range & radars

Select vp files on the date range and radars we defined in our settings (_file selection_):

```{r extract_get_file_paths}
vp_file_paths <- bioRad::retrieve_vp_paths(
  start_date = settings$general$start_date,
  end_date = settings$general$end_date,
  radar = settings$general$radar_ids_3char,
  path = raw_data_dir
)
```

The file paths we get back only start from the data directory, so we need to append those with the path to the data directory itself:

```{r extract_complete_file_paths}
vp_file_paths <- paste0(raw_data_dir, vp_file_paths)
```

There are **`r length(vp_file_paths)` vp files** that meet our criteria. Preview:

```{r extract_preview_file_paths}
head(vp_file_paths, 5)
```

## Read vp files

We read all those files with bioRad. This could take a while (â˜• time):

```{r extract_read_vp_data_get_coffee}
vp_files <- bioRad::readvp.list(vp_file_paths)
```

## Select variables

A single vp file contains a data frame with heights as rows and variables as columns: 

```{r extract_show_vp_data_structure}
str(vp_files[[1]]$data)
```

We only need a couple of variables (`HGHT`, `u`, `v`, `dens`, `dd`, `ff`) and attributes (`date_time` and `radar_id`) from the vp_files (_column selection_). We retrieve those with the custom function `vp_to_df()` after which we combine all data in one single data frame, sorted on `radar_id`, `date_time`, and `HGHT`:

```{r extact_select_columns_and_sort}
vp_data <- list()
variables = c("u", "v", "dens", "dd", "ff") # HGHT is added by default in vp_to_df()
for (i in seq_along(vp_files)) {
  vp_data[[i]] <- vp_to_df(vp_files[[i]], variables)
}
dplyr::bind_rows(vp_data) %>%
dplyr::arrange(radar_id, datetime, HGHT) -> vp_data
```

That data frame contains **`r nrow(vp_data)` records**.

## Calculate MTR per height

We also want migration traffic rate (mtr) per height for further analysis, so we calculate and add it as an extra column:

```{r extract_calculate_mtr}
vp_data$mtr <- vp_data$ff * vp_data$dens / 5
```

Preview:

```{r extract_vp_data_preview}
head(vp_data, 20)
```

## Select heights

Select the heights that fall within the height range we defined for each radar in our settings (_horizontal_selection_), with minimum and maximum _inclusive_. If no height settings are defined for a radar, the `load_settings.R` function will use our general height settings for that radar[^2].

[^2]: We can specify `min_height`, `max_height`, both or none for a radar. If the value is something other than an integer, the general `min_height` or `max_height` is used instead. That means we don't need to filter the data on the general height range, as those will be applied for each radar already.


```{r extract_select_heights}
# Rather than using a complicated combination of AND and OR filters, we select
# data radar by radar, and store the selected rows in separate data frames
# (e.g. vp_data_temp$searl). We then combine and sort those back into a single 
# data frame, which we store again as vp_data.
vp_data_temp <- list()
for (radar in settings$radars) {
  vp_data %>%
  dplyr::filter(
    radar_id == radar$radar_id & 
    HGHT >= radar$min_height & 
    HGHT <= radar$max_height
  ) -> vp_data_temp[[radar$radar_id]]
}

dplyr::bind_rows(vp_data_temp) %>%
# Sorting the data is not really necessary, but we just do it for good measure.
dplyr::arrange(radar_id, date_time, HGHT) -> vp_data
```

Our data frame now contains **`r nrow(vp_data)` records**. Preview:

```{r extract_select_heights_preview}
head(vp_data, 20)
```

## Select specific dates per radar

...

## Export to a CSV file

Finally, we export the data to a CSV file[^3]:

```{r extract_vp_export}
write.csv(vp_data, file = "../data/interim/vp_data.csv", na = "", row.names = FALSE)
```

[^3]: The data frame `vp_data` contains `NaN` and `NA` values, [which have a different meaning](https://github.com/enram/timamp-etl/issues/10#issuecomment-302235736). That difference gets lost in the CSV file: all are treated as blank (= `NA`) values, which is fine for visualizations. If you want to keep that difference, you need work further with `vp_data`.
